#include "../headers/player.h"
#include "raymath.h"
#include "stdio.h"
#include "../headers/game.h"
#include "../headers/textures.h"

int player_width = 75;
int player_height = 75;

const int axeWidth = 25;
const int axeHeight = 25;

const int axeHoverRadius = 60;

const float axeBaseSpeed = 10;
const float axeRecallSpeed = 13;
const float axeSpeedIncrementThrown = 0.5;
const float axeSpeedIncrementRecall = 0.75;

const float playerBaseSpeed = 5.0f;

void playerInit(Player *player){
    player->pos = (Vector2){1280/2, 720/2};
    player->rec = (Rectangle){player->pos.x - player_width/2, player->pos.y - player_height/2, player_width, player_height};
    player->speed = 5.0f;
    player->dir = (Vector2){0,0};
    player->state = NOTHING;
    player->health = 100.0f;
    player->baseHealth = 100.0f;

    //Weapon stuff
    player->axe.pos = (Vector2){player->pos.x, player->pos.y};
    player->axe.rec = (Rectangle){player->axe.pos.x - axeWidth/2,player->axe.pos.y - axeHeight/2, axeWidth, axeHeight};
    player->axe.throwSpeed = axeBaseSpeed;
    player->axe.recallSpeed = axeRecallSpeed;
    player->axe.state = HOLDING;
    player->axe.attackPos = (Vector2){0,0};
    player->axe.attackCheckRadius = 15.0;
    player->axe.damage = 50;

    //Animations
    animationInit(&player->playerIdleAnim, 0, playerIdleTexture, 16, 4, 0, 0);
    animationInit(&player->playerSideAnim, 0, playerSideTexture, 16, 5, 0, 0);

    //Aniamtion related variables
    player->animationDir = 1;
    player->animState = IDLE;

}

void playerUpdate(Player *player){
    playerMovement(player);

    axeUpdate(player);
}

void playerMovement(Player *player){
    
    switch (player->state){
        case NOTHING:
            break;
        case PULLING_IN:
            player->dir = (Vector2){player->axe.pos.x - player->pos.x, player->axe.pos.y - player->pos.y};
            player->speed += 1;

            if(player->axe.state == HOLDING){
                player->state = NOTHING;
                player->speed = playerBaseSpeed;
            }
            break;

    }
    if(player->axe.state != HOLDING && IsKeyPressed(KEY_SPACE)){
        player->state = PULLING_IN;
    }

    if(player->state != PULLING_IN){
        //Get input
        if(IsKeyDown(KEY_A)){
            player->dir.x -= 1;
            player->animationDir = -1;
        }
        else if(IsKeyDown(KEY_D)){
            player->dir.x += 1;
            player->animationDir = 1;
        }

        if(IsKeyDown(KEY_W)){
            player->dir.y -= 1;
        }
        else if(IsKeyDown(KEY_S)){
            player->dir.y += 1;
        }
    }
    
    //Update anim state
    if(player->dir.x != 0 || player->dir.y != 0){
        player->animState = RUNNING;
    }
    else{
        player->animState = IDLE;
    }

    //Add direction to player but first normalize
    player->dir = Vector2Normalize(player->dir);
    player->pos.x += player->dir.x * player->speed;
    player->pos.y += player->dir.y * player->speed;

    //Reset dir
    player->dir = (Vector2){0,0};

    //Update rec
    player->rec = (Rectangle){player->pos.x - player_width/2, player->pos.y - player_height/2, player_width, player_height};

}

void axeUpdate(Player *player){
    switch (player->axe.state){
        case HOLDING:

            //Setting axe position based on mouse Pos
            Vector2 mouseDirection = {worldMouse.x - player->pos.x, worldMouse.y - player->pos.y};
            mouseDirection = Vector2Normalize(mouseDirection);
            double angle = atan2(mouseDirection.y, mouseDirection.x);
            player->axe.pos = (Vector2){player->pos.x+ cosf(angle) * axeHoverRadius, player->pos.y + 10 + sinf(angle) * axeHoverRadius};


            if(IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
                player->axe.attackPos = worldMouse;
                player->axe.dir = (Vector2){player->axe.attackPos.x - player->axe.rec.x, player->axe.attackPos.y - player->axe.rec.y};
                player->axe.dir = Vector2Normalize(player->axe.dir); 
                player->axe.state = THROWN;
            }

            break;

        case THROWN:

            player->axe.pos.x += player->axe.dir.x * player->axe.throwSpeed;
            player->axe.pos.y += player->axe.dir.y * player->axe.throwSpeed;

            player->axe.throwSpeed += axeSpeedIncrementThrown;

            if(CheckCollisionCircleRec(player->axe.attackPos, player->axe.attackCheckRadius, player->axe.rec)){
                player->axe.attackPos = (Vector2){0,0};
                player->axe.dir = (Vector2){0,0};
                player->axe.state = DONE_THROW;

                player->axe.throwSpeed = axeBaseSpeed;
            }

            if(IsMouseButtonPressed(MOUSE_BUTTON_RIGHT)){
                player->axe.attackPos = (Vector2){0,0};
                player->axe.dir = (Vector2){0,0};
                player->axe.state = RECALL;

                player->axe.throwSpeed = axeBaseSpeed;
            }
            break;
            

        case DONE_THROW:
            if(IsMouseButtonPressed(MOUSE_BUTTON_RIGHT)){
                player->axe.dir = (Vector2){player->pos.x - 32.5 - player->axe.pos.x, player->pos.y - 32.5 - player->axe.pos.y};
                player->axe.state = RECALL;
            }
            break;

        case RECALL:
            if(!CheckCollisionRecs(player->rec, player->axe.rec)){
                player->axe.dir = (Vector2){player->pos.x - player->axe.pos.x, player->pos.y - player->axe.pos.y};
                player->axe.dir = Vector2Normalize(player->axe.dir); 
                player->axe.pos.x += player->axe.dir.x * player->axe.recallSpeed;
                player->axe.pos.y += player->axe.dir.y * player->axe.recallSpeed;   
                player->axe.recallSpeed += axeSpeedIncrementRecall;
            }
            else{
                player->axe.state = HOLDING;
                player->axe.recallSpeed = axeRecallSpeed;
            }
            break;
    }

    //Returns 
    if((CheckCollisionRecs(player->rec, player->axe.rec)) && player->state == PULLING_IN){
        player->axe.state = HOLDING;
    }

    //Update axe rec
    player->axe.rec = (Rectangle){player->axe.pos.x - axeWidth/2,player->axe.pos.y - axeHeight/2, axeWidth, axeHeight};
}

void playerDraw(Player *player){
    

    //if(player->axe.state != 0){
        DrawRectangleRec(player->axe.rec, BLUE);
    //}
    
    switch (player->animState){
        case IDLE:
            playAnimation(&player->playerIdleAnim, player->rec, player->animationDir, 0.25);
            break;
        
        case RUNNING:
            playAnimation(&player->playerSideAnim, player->rec, player->animationDir, 0.15);
            break;
    }

    


}